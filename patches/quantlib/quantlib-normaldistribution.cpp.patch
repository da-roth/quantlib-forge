diff --git a/ql/math/distributions/normaldistribution.cpp b/ql/math/distributions/normaldistribution.cpp
index 06b108e..d4037c5 100644
--- a/ql/math/distributions/normaldistribution.cpp
+++ b/ql/math/distributions/normaldistribution.cpp
@@ -5,6 +5,7 @@
  Copyright (C) 2002, 2003 Ferdinando Ametrano
  Copyright (C) 2008 StatPro Italia srl
  Copyright (C) 2010 Kakhkhor Abdijalilov
+ Copyright (C) 2025 QuantLib-Forge Authors (Forge-aware modifications)
 
  This file is part of QuantLib, a free-software/open-source library
  for financial quantitative analysts and developers - http://quantlib.org/
@@ -22,36 +23,53 @@
 
 #include <ql/math/distributions/normaldistribution.hpp>
 #include <ql/math/comparison.hpp>
+#include <expressions/abool.hpp>
+#include <expressions/abool_helpers.hpp>
+#include <expressions/ExpressionTemplates/UnaryOperators.hpp>
 
 #include <boost/math/distributions/normal.hpp>
 
 namespace QuantLib {
 
+    namespace {
+        // Compute asymptotic expansion for very negative z
+        // Following (26.2.12) on page 408 in M. Abramowitz and A. Stegun
+        // Unrolled loop for Forge to record all operations in the computation graph
+        Real computeAsymptoticExpansion(Real z, Real gaussian_z) {
+            Real zsqr = z * z;
+            Real sum = Real(1.0);
+            Real g = Real(1.0);
+
+            // Unroll the loop - typically converges in 5-10 iterations for |z| > 3
+            // We use 20 iterations to cover all practical cases
+            for (int i = 1; i <= 20; i++) {
+                Real x = Real(4.0 * i - 3.0) / zsqr;
+                Real y = x * (Real(4.0 * i - 1.0) / zsqr);
+                Real a = g * (x - y);
+                sum = sum - a;
+                g = g * y;
+            }
+
+            return -gaussian_z / z * sum;
+        }
+    }
+
+    // Forge-aware CumulativeNormalDistribution using ABool::If for all branches
     Real CumulativeNormalDistribution::operator()(Real z) const {
-        //QL_REQUIRE(!(z >= average_ && 2.0*average_-z > average_),
-        //           "not a real number. ");
         z = (z - average_) / sigma_;
 
-        Real result = 0.5 * ( 1.0 + errorFunction_( z*M_SQRT_2 ) );
-        if (result<=1e-8) { //todo: investigate the threshold level
-            // Asymptotic expansion for very negative z following (26.2.12)
-            // on page 408 in M. Abramowitz and A. Stegun,
-            // Pocketbook of Mathematical Functions, ISBN 3-87144818-4.
-            Real sum=1.0, zsqr=z*z, i=1.0, g=1.0, x, y,
-                 a=QL_MAX_REAL, lasta;
-            do {
-                lasta=a;
-                x = (4.0*i-3.0)/zsqr;
-                y = x*((4.0*i-1)/zsqr);
-                a = g*(x-y);
-                sum -= a;
-                g *= y;
-                ++i;
-                a = std::fabs(a);
-            } while (lasta>a && a>=std::fabs(sum*QL_EPSILON));
-            result = -gaussian_(z)/z*sum;
-        }
-        return result;
+        Real result = Real(0.5) * (Real(1.0) + errorFunction_(z * M_SQRT_2));
+
+        // Compute asymptotic expansion (always computed, selected via ABool::If)
+        Real gaussian_z = gaussian_(z);
+        Real asymptotic_result = computeAsymptoticExpansion(z, gaussian_z);
+
+        // Use ABool::If to select between normal result and asymptotic expansion
+        // This ensures Forge records both branches in the computation graph
+        forge::ABool cond_use_asymptotic = forge::lessEqual(
+            result.forgeValue(), Real(1e-8).forgeValue());
+
+        return forge::ABool::If(cond_use_asymptotic, asymptotic_result, result);
     }
 
     #if !defined(QL_PATCH_SOLARIS)
